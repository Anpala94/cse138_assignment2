
from flask import Flask, request
import os
import requests
import sys
# Constants
PORT = 13800
SUCCESS = None

sys.stdout.flush()
app = Flask(__name__)



@app.route("/")
def hello():
    return "Hello, World!"

# helper functions
def get_key_and_value_from_request():
    key = None
    value = None

    request_body = request.get_json()

    # parse the key and value from the request body
    if request_body is not None:
        if 'key' in request_body:
            key = request_body['key']
        if 'val' in request_body:
            value = request_body['val']

    return (key, value)

def validate_key_value_length(key, value):
    if (key is not None and len(key) > 200) or (value is not None and len(value) > 200):
        return ('{"error": "key or val too long"}', 400)
    return SUCCESS


def validate_input(key, value, request_method):
    if not key or request_method == "PUT" and not value:
        return ('{"error": "bad ' + request_method +'"}', 400)
    return SUCCESS



@app.route('/kvs', methods = ['GET', 'PUT', 'DELETE'])
def process_hello():
    if main_instance:
        # parse body from request
        key, value = get_key_and_value_from_request()

        # validate key and value
        if (validation_response := validate_input(key, value, request.method)) is not SUCCESS:
            return validation_response
        # validate LENGTH of key&value
        if (validation_response := validate_key_value_length(key, value)) is not SUCCESS:
            return validation_response

        if request.method == 'PUT':
            if key not in d:
                d[key] = value
                return ('{"replaced": false}', 201)
            else:
                previous_value = d[key]
                d[key] = value
                return ('{"replaced": true, "prev": "' + previous_value + '"}', 200)
        elif request.method == 'GET':
            if key in d:
                sample_value = d[key]
                d.pop(key)
                return ('{"val": "' + sample_value + '"}', 200)
            else:
                return ('{"error": "not found"}', 404)
        elif request.method == 'DELETE':
            if key in d:
                sample_value = d[key]
                d.pop(key)
                return ('{"prev": "' + sample_value + '"}', 200)
            else:
                return ('{"error": "not found"}', 404)
    else:
        # forward requests to forwarding_address, then forward the response (including errors generated by a follower, if its upstream is a follower) to its downstream.
        try:
            upstream_response = requests.request(
                method=request.method,
                url=forwarding_address + request.full_path,
                headers={k: v for k, v in request.headers},
                data=request.get_data(),
                params=request.args,
                timeout=10,
            )
        except requests.exceptions.Timeout:
            return '{"error": "upstream down", "upstream": "10.10.0.42:13800"}', 503
        else:
            return upstream_response.content, upstream_response.status_code, upstream_response.headers.items()




if __name__ == "__main__":
    # setup
    d = {}
    forwarding_address = os.environ.get('FORWARDING_ADDRESS')
    main_instance = forwarding_address == None

    # start
    app.run(port=PORT, host='0.0.0.0')
